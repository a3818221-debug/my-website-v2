<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chessboard Pro — Canvas + chess.js</title>
  <!--
    Single-file chessboard you can drop on GitHub Pages.
    Features: drag & drop, legal move validation (chess.js), FEN/PGN load-save,
    animated moves, highlights, flip board, undo/redo, autoplay line, sounds.
    No build step required. Works as a static file.
  -->
  <style>
    :root{
      --bg:#0b1020; --panel:#0f162b; --ink:#e9edff; --muted:#a6b1c9; --accent:#7aa2ff;
      --light:#eef3ff; --dark:#26304d; --green:#14c38e; --red:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0; background:radial-gradient(1000px 500px at 0% -10%, #153 0%, transparent 40%),
                         radial-gradient(1200px 600px at 110% 110%, #357 0%, transparent 40%), var(--bg);
         font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; color:var(--ink);
         min-height:100dvh; display:flex; align-items:center; justify-content:center; padding:18px}
    .app{ width:min(1200px,96vw); display:grid; grid-template-columns: 1fr 380px; gap:16px; align-items:start }
    @media (max-width: 980px){ .app{ grid-template-columns: 1fr } }
    .card{ background:linear-gradient(180deg, #141b33, #0f1527); border:1px solid #1b2548; border-radius:18px; padding:14px; box-shadow: 0 20px 60px #0008 }
    h1{ margin:4px 6px 10px; font-size: clamp(18px, 2.2vw, 28px)}
    .board-wrap{ aspect-ratio:1/1; position:relative }
    canvas{ width:100%; height:100%; display:block; border-radius:16px; border:1px solid #24335e; background:#0b122a }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center }
    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px }
    button, select{
      appearance:none; border:1px solid #2b3d76; background:linear-gradient(180deg,#1b2a55,#142043);
      color:var(--light); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; letter-spacing:.2px;
      box-shadow:inset 0 0 0 1px #4c64c233, 0 8px 20px #0007; transition: transform .06s ease, filter .15s ease;
    }
    button:hover{ filter:brightness(1.08) } button:active{ transform:scale(.98) }
    .ghost{ background:transparent; border-color:#23315f; color:var(--muted) }
    .ok{ border-color:#1c8f70 } .danger{ border-color:#8f1c1c }
    label{ font-size:12px; color:var(--muted) }
    .inp{ width:100%; background:#0e1530; border:1px solid #283768; color:#e8edff; border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }
    .badge{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #2a3c7a; background:#111a38}
    .dot{width:10px; height:10px; border-radius:999px; background:var(--accent); box-shadow:0 0 10px var(--accent)}
    .side{ display:grid; gap:10px }
    .moves{ height:160px; overflow:auto; background:#0b1330; border:1px solid #24335e; border-radius:12px; padding:8px; font: 13px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }
    .moves b{ color:#b9c7ff }
    .hint{ font-size:12px; color:#92a0c5 }
  </style>
  <!-- chess.js (classic UMD build) from cdnjs. Provides window.Chess -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js" integrity="sha512-0t9sU6F6c0AuANqT9mRIt+3m0j9x1gLu8oJ4sH6b//kHTpN9qVDRzY8bqQF5p0q0hIE2C8Dq9Ff8S1z1mC4O8w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>Chessboard Pro — Drag & Drop + Legal Moves</h1>
      <div class="board-wrap"><canvas id="board" width="800" height="800"></canvas></div>
      <div class="row" style="margin-top:10px">
        <span class="badge"><span class="dot"></span> <span id="status">Ready</span></span>
        <button id="flip" class="ghost">Flip Board</button>
        <button id="undo" class="ghost">Undo</button>
        <button id="redo" class="ghost">Redo</button>
        <button id="reset" class="ghost">Reset</button>
      </div>
    </div><div class="card side">
  <div class="grid">
    <button id="playLine">▶ Autoplay line</button>
    <button id="stopLine" class="ghost">⏸ Stop</button>
  </div>
  <label>Speed <input id="speed" type="range" min="150" max="1500" step="50" value="600" class="inp"></label>
  <label>FEN <textarea id="fen" rows="2" class="inp"></textarea></label>
  <div class="grid">
    <button id="loadFen" class="ok">Load FEN</button>
    <button id="copyFen" class="ghost">Copy FEN</button>
  </div>
  <label>PGN <textarea id="pgn" rows="4" class="inp"></textarea></label>
  <div class="grid">
    <button id="loadPgn" class="ok">Load PGN</button>
    <button id="copyPgn" class="ghost">Copy PGN</button>
  </div>
  <div class="moves" id="moves"></div>
  <p class="hint">Drag a piece to a highlighted square. Legal moves only (including castling, en-passant, promotions → queen). Space = autoplay/stop, F = flip, U/R = undo/redo.</p>
</div>

  </div>  <audio id="s-move" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mpeg">
  </audio>
  <audio id="s-capture" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mpeg">
  </audio>  <script>
    // ====== Setup chess engine state (rules only) ======
    const game = new Chess(); // provided by chess.js

    // ====== Canvas board rendering ======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const S = 100; // 8x8 * 100 = 800
    const colorLight = '#e9edf7';
    const colorDark  = '#7e8ab3';
    const hlFrom = '#ffd84c99';
    const hlTo   = '#3bf1c388';
    const hlMove = '#33d1ff44';

    const PIECES = { K:'♔', Q:'♕', R:'♖', B:'♗', N:'♘', P:'♙' };

    let orientation = 'w'; // 'w' bottom or 'b' bottom
    let dragging = null; // {piece:{type,color}, from:{r,c}, mouse:{x,y}}
    let lastMove = null; // {from,to}
    let highlights = []; // [{r,c}]

    const sMove = document.getElementById('s-move');
    const sCap  = document.getElementById('s-capture');

    function rcToAlg({r,c}){ const file = 'abcdefgh'[c]; const rank = 8-r; return file+rank; }
    function algToRC(s){ const c='abcdefgh'.indexOf(s[0]); const r = 8-parseInt(s[1],10); return {r,c}; }

    function boardSquareAt(x,y){
      const rect = canvas.getBoundingClientRect();
      const xx = (x - rect.left) / rect.width; // 0..1
      const yy = (y - rect.top) / rect.height;
      let c = Math.floor(xx * 8);
      let r = Math.floor(yy * 8);
      if(orientation==='b'){ c = 7-c; r = 7-r; }
      return {r,c};
    }

    function toScreenRC({r,c}){
      if(orientation==='b'){ r = 7-r; c = 7-c; }
      return {x: c*S, y: r*S};
    }

    function draw(){
      // squares
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          ctx.fillStyle = ((r+c)%2===0)? colorLight : colorDark;
          roundRect(ctx, c*S, r*S, S, S, 14); ctx.fill();
        }
      }
      // last move halo
      if(lastMove){
        ctx.fillStyle = hlMove; const a = toScreenRC(algToRC(lastMove.from)); const b = toScreenRC(algToRC(lastMove.to));
        roundRect(ctx, a.x, a.y, S, S, 14); ctx.fill(); roundRect(ctx, b.x, b.y, S, S, 14); ctx.fill();
      }
      // highlight legal targets
      for(const h of highlights){ const p = toScreenRC(h); ctx.fillStyle = hlTo; roundRect(ctx, p.x, p.y, S, S, 14); ctx.fill(); }

      // ranks/files
      ctx.fillStyle = '#0b122a'; ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
      for(let i=0;i<8;i++){
        ctx.fillText('abcdefgh'[orientation==='w'?i:7-i], 8 + i*S, 14);
        ctx.fillText(String(orientation==='w'?8-i:i+1), 8, 18 + i*S);
      }

      // draw pieces
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='64px system-ui, Segoe UI Symbol, Noto Color Emoji, serif';
      const board = game.board(); // 8x8 array of pieces or null
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const piece = board[r][c]; if(!piece) continue;
          // skip source if dragging this piece
          if(dragging && dragging.from.r===r && dragging.from.c===c) continue;
          const {x,y} = toScreenRC({r,c});
          ctx.fillStyle = (piece.color==='w')? '#ffffff' : '#1a2540';
          ctx.shadowColor = '#0008'; ctx.shadowBlur = 14;
          ctx.fillText(PIECES[piece.type.toUpperCase()], x + S/2, y + S/2 + 2);
          ctx.shadowBlur = 0;
        }
      }

      // draw dragging piece following mouse
      if(dragging){
        const piece = dragging.piece; const {x,y} = dragging.mouse;
        ctx.fillStyle = (piece.color==='w')? '#ffffff' : '#1a2540';
        ctx.shadowColor = '#000c'; ctx.shadowBlur = 22;
        ctx.fillText(PIECES[piece.type.toUpperCase()], x, y);
        ctx.shadowBlur = 0;
      }
    }

    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    // ====== Drag & Drop ======
    canvas.addEventListener('pointerdown', e=>{
      const sq = boardSquareAt(e.clientX, e.clientY);
      const piece = game.board()[sq.r][sq.c];
      if(!piece) return;
      // Only allow dragging side to move (optional)
      if(piece.color !== game.turn()) return;
      dragging = { piece, from:sq, mouse: toCanvasPoint(e) };
      const moves = game.moves({ square: rcToAlg(sq), verbose: true });
      highlights = moves.map(m=>algToRC(m.to));
      draw();
    });

    canvas.addEventListener('pointermove', e=>{
      if(!dragging) return;
      dragging.mouse = toCanvasPoint(e);
      draw();
    });

    canvas.addEventListener('pointerup', e=>{
      if(!dragging) return;
      const target = boardSquareAt(e.clientX, e.clientY);
      const from = rcToAlg(dragging.from); const to = rcToAlg(target);
      // Try legal move; auto-queen promotions
      const move = game.move({ from, to, promotion:'q' });
      if(move){
        playSound(move.captured ? 'cap' : 'mv');
        lastMove = {from, to};
        pushHistory(move);
        updateSideUI();
        animateMove(dragging.from, target, ()=>{ dragging=null; highlights=[]; draw(); });
      } else { dragging=null; highlights=[]; draw(); }
    });

    function toCanvasPoint(e){ const rect = canvas.getBoundingClientRect(); const x=(e.clientX-rect.left)/rect.width*canvas.width; const y=(e.clientY-rect.top)/rect.height*canvas.height; return {x,y}; }

    // ====== Animation ======
    let anim=null; // {from:{r,c}, to:{r,c}, t:0, dur}
    function animateMove(from, to, onDone){
      anim = { from, to, t:0, dur:+speed.value };
      const piece = game.board()[to.r][to.c]; // now at target
      const start = performance.now();
      const id = requestAnimationFrame(function step(ts){
        anim.t = Math.min(1, (ts-start)/anim.dur);
        draw();
        // overlay anim ghost
        const a = toScreenRC(from), b = toScreenRC(to); const x = lerp(a.x, b.x, ease(anim.t)) + S/2; const y = lerp(a.y, b.y, ease(anim.t)) + S/2 + 2;
        ctx.fillStyle = (piece.color==='w')? '#ffffff' : '#1a2540'; ctx.shadowColor = '#000a'; ctx.shadowBlur = 16; ctx.fillText(PIECES[piece.type.toUpperCase()], x, y); ctx.shadowBlur=0;
        if(anim.t<1){ requestAnimationFrame(step); } else { anim=null; onDone&&onDone(); }
      });
    }
    function lerp(a,b,t){ return a + (b-a)*t } function ease(t){ return 1 - Math.pow(1-t, 3); }

    // ====== Side UI controls ======
    const speed = document.getElementById('speed');
    const status = document.getElementById('status');
    const movesEl = document.getElementById('moves');
    const fenEl = document.getElementById('fen');
    const pgnEl = document.getElementById('pgn');

    document.getElementById('flip').onclick = ()=>{ orientation = (orientation==='w'?'b':'w'); draw(); };
    document.getElementById('reset').onclick = ()=>{ stopAutoplay(); game.reset(); lastMove=null; history=[]; redoStack=[]; updateSideUI(); draw(); };
    document.getElementById('undo').onclick = undoMove; document.getElementById('redo').onclick = redoMove;

    document.getElementById('loadFen').onclick = ()=>{ try{ game.load(fenEl.value.trim()); lastMove=null; history=[]; redoStack=[]; updateSideUI(); draw(); ok('Loaded FEN'); }catch(e){ danger('Bad FEN'); } };
    document.getElementById('copyFen').onclick = ()=>{ navigator.clipboard.writeText(game.fen()); ok('FEN copied'); };

    document.getElementById('loadPgn').onclick = ()=>{ try{ game.reset(); game.load_pgn(pgnEl.value.trim()); rebuildHistoryFromGame(); updateSideUI(); draw(); ok('Loaded PGN'); }catch(e){ danger('Bad PGN'); } };
    document.getElementById('copyPgn').onclick = ()=>{ navigator.clipboard.writeText(game.pgn()); ok('PGN copied'); };

    // ====== Move history + undo/redo ======
    let history = []; // verbose moves as returned by chess.js
    let redoStack = [];

    function pushHistory(m){ history.push(m); redoStack=[]; }
    function undoMove(){ stopAutoplay(); const m = game.undo(); if(m){ redoStack.push(m); lastMove=null; updateSideUI(); draw(); } }
    function redoMove(){ stopAutoplay(); const m = redoStack.pop(); if(!m) return; const mv = game.move(m); if(mv){ pushHistory(mv); lastMove={from:mv.from, to:mv.to}; updateSideUI(); draw(); } }

    function rebuildHistoryFromGame(){ history = game.history({ verbose:true }); redoStack=[]; if(history.length){ const last = history[history.length-1]; lastMove={from:last.from, to:last.to}; } else { lastMove=null; } }

    function updateSideUI(){
      fenEl.value = game.fen();
      pgnEl.value = game.pgn();
      // build move list
      const san = game.history();
      let html = ''; for(let i=0;i<san.length;i+=2){ const n = 1+i/2; html += `<b>${n}.</b> ${san[i]||''} ${san[i+1]||''}<br>`; }
      movesEl.innerHTML = html || '<em>No moves yet</em>';
      status.textContent = (game.in_checkmate()? 'Checkmate' : game.in_draw()? 'Draw' : (game.turn()==='w'?'White':'Black') + ' to move');
    }

    // ====== Autoplay a prepared line ======
    let lineTimer=null; let lineQueue=[];
    document.getElementById('playLine').onclick = ()=>{
      if(lineTimer) return stopAutoplay();
      // take current PGN and replay from start; or if none, a sample line
      const sample = ['e4','e5','Nf3','Nc6','Bc4','Nf6','Ng5','d5','exd5','Na5'];
      let sanList = game.history().length? game.history() : sample;
      game.reset(); rebuildHistoryFromGame(); draw();
      lineQueue = sanList.slice();
      nextAuto();
    };
    document.getElementById('stopLine').onclick = stopAutoplay;
    function nextAuto(){
      if(!lineQueue.length){ stopAutoplay(); return; }
      const san = lineQueue.shift();
      const mv = game.move(san, { sloppy:true });
      if(mv){ pushHistory(mv); lastMove={from:mv.from, to:mv.to}; updateSideUI(); animateMove(algToRC(mv.from), algToRC(mv.to), ()=>{ lineTimer = setTimeout(nextAuto, +speed.value*0.6); }); }
    }
    function stopAutoplay(){ if(lineTimer){ clearTimeout(lineTimer); lineTimer=null; } }

    function ok(msg){ status.textContent = msg; }
    function danger(msg){ status.textContent = msg; }

    function playSound(kind){ try{ (kind==='cap'? sCap : sMove).currentTime=0; (kind==='cap'? sCap : sMove).play(); }catch(e){} }

    // ====== Init ======
    updateSideUI(); draw();

    // hotkeys
    document.addEventListener('keydown', (e)=>{
      if(e.code==='Space'){ e.preventDefault(); if(lineTimer) stopAutoplay(); else document.getElementById('playLine').click(); }
      if(e.key==='f' || e.key==='F') document.getElementById('flip').click();
      if(e.key==='u' || e.key==='U') undoMove();
      if(e.key==='r' || e.key==='R') redoMove();
    });
  </script></body>
</html>
